# Msg streaming design

## 1. Overview

### 1.1 Push

```
Push is mainly used to push personalized feeds, and such feed messages will only trigger specified users

This method can optimize the user's feed performance, but it will occupy message storage resources

The scene is as follows:
Artist's new album release, follow, comment, application private message, etc.
```

### 1.2 Pull

```
Pull is mainly used for system-level feed related, such feed messages almost involve most users

This method can save more message storage resources, but it will be time-consuming for users to actively pull Feed messages, and it is also a test for interface performance

The scene is as follows:
System messages, user group messages, activity messages, etc.
```

## 2. Technology selection

```
The difficulty lies in the need to balance performance and resources

In view of this, we need to carefully evaluate the characteristics of each component and choose

CDN: Dynamic acceleration, intelligently select the best route back to the source for acquisition
Nginx: A reverse proxy server with excellent performance
Redis: Distributed cache with excellent performance and rich data types
Caffeine: A high-performance local cache
```

## 3. Architecture design

![Msg streaming design](../Material/image/Msg%20streaming%20design.png)

## 4. Link design

### 4.1 Generate Msg

```markdown
The service provides an RPC interface for sending messages

When the upstream service performs business operations, it uniformly calls this interface to send messages

Messages will be stuffed into different Redis Lists according to different business types
```

### 4.2 Push Msg

```markdown


```

### 4.3 Pull Msg

```markdown
In order to optimize the performance of getting messages, we use Redis to store user messages

Data structure usage: List

The Msg generated by the function will be pushed to the user-related Redis key

The logged-in user obtains user information according to uid

Users who are not logged in get device information according to the unique code of the device

Each request will bring the currentMsgId, get the message larger than the MsgId, and delete the message smaller than the MsgId

After pulling the message, in order to ensure that the capacity will not grow all the time, the message list will also be trimmed
```

## 5. implementation details

### 5.1 Generate Msg

#### 5.1.1 Asynchronous Processing


### 5.2 Push Msg


### 5.3 Pull Msg


## 6. Optimization direction








